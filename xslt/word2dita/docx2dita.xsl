<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:local="urn:local-functions"
      
      xmlns:rsiwp="http://reallysi.com/namespaces/generic-wordprocessing-xml"
      xmlns:stylemap="http://reallysi.com/namespaces/style-to-tag-map"
      
      exclude-result-prefixes="xs rsiwp stylemap local"
      version="2.0">

  <!--==========================================
    DOCX to DITA generic transformation
    
    Copyright (c) 2009 DITA For Publishers, Inc.

    Transforms a DOCX document.xml file into a DITA topic using
    a style-to-tag mapping.
    
    This transform is intended to be the base for more specialized
    transforms that provide style-specific overrides.
    
    The input to this transform is the document.xml file within a DOCX
    package.
    
    
    Originally developed by Really Strategies, Inc.
    
    =========================================== -->
  
  <xsl:include href="wordml2simple.xsl"/>
  
  
  
  <xsl:output 
    doctype-public="urn:pubid:astd.com/doctypes/dita/article"
    doctype-system="article.dtd"
  />
  
  <xsl:template match="/" priority="10">
    <xsl:variable name="simpleWpDoc" as="element()">
      <xsl:call-template name="processDocumentXml"/>
    </xsl:variable>
    <xsl:apply-templates select="$simpleWpDoc"/>
  </xsl:template>
  
  <xsl:template match="rsiwp:document">
    <!-- First <p> in doc should be title for the root topic. If it's not, bail -->  
    <xsl:variable name="firstP" select="rsiwp:body/(rsiwp:p|rsiwp:table)[1]" as="element()?"/>
<!--    <xsl:message> + [DEBUG] firstP=<xsl:sequence select="$firstP"/></xsl:message>-->
    <xsl:if test="$firstP and not(local:isRootTopicTitle($firstP))">
      <xsl:message terminate="yes"> + [ERROR] The first block in the Word document must be mapped to the root topic title.
        First para is style <xsl:sequence select="$firstP/@style"/>, mapped as <xsl:sequence 
          select="key('styleMaps', string($firstP/@style), $styleMapDoc)[1]"/> 
      </xsl:message>
    </xsl:if>
    <xsl:call-template name="makeTopic">
      <xsl:with-param name="content" select="rsiwp:body/(rsiwp:p|rsiwp:table)"/>
      <xsl:with-param name="level" select="0"/>
    </xsl:call-template>
  </xsl:template>
  
  <xsl:template match="rsiwp:p[@structureType = 'skip']" priority="10"/>
  
  <xsl:template match="rsiwp:p" name="transformPara">
    <xsl:variable name="tagName" as="xs:string"
      select="
      if (@tagName) 
      then string(@tagName)
      else 'p'
      "
    />
    <xsl:if test="not(./@tagName)">
      <xsl:message> + [WARNING] No style to tag mapping for paragraph style "<xsl:sequence select="string(@style)"/>"</xsl:message>
    </xsl:if>
    <xsl:element name="{$tagName}">
      <xsl:call-template name="transformParaContent"/>    
    </xsl:element>
  </xsl:template>
  
  <xsl:template name="transformParaContent">
    <!-- Transforms the content of a paragraph, where the containing
         element is generated by the caller. -->
    <xsl:choose>
      <xsl:when test="@useContent = 'elementsOnly'">
        <xsl:apply-templates mode="p-content" select="*"/>
      </xsl:when>
      <xsl:when test="@putValueIn = 'valueAtt'">
        <xsl:attribute name="value" select="string(.)"/>
        <xsl:if test="@dataName">
          <xsl:attribute name="name" select="string(@dataName)"/>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="p-content"/>
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:template>
  
  <xsl:template match="rsiwp:table">
    <xsl:message> + [DEBUG] rsiwp:table: Starting...</xsl:message>
    <xsl:variable name="tagName" as="xs:string"
      select="
      if (@tagName) 
      then string(@tagName)
      else 'table'
      "
    />
    <xsl:element name="{$tagName}">
      <!-- FIXME: Need to account for table heads and table bodies -->
      <tgroup cols="{count(rsiwp:cols/rsiwp:col)}">
        <xsl:apply-templates select="rsiwp:cols"/>
        <tbody>
          <xsl:apply-templates select="rsiwp:tr"/>
        </tbody>        
      </tgroup>
    </xsl:element>
  </xsl:template>
  
  <xsl:template match="rsiwp:cols">
    <xsl:apply-templates/>
  </xsl:template>
  
  <xsl:template match="rsiwp:col">
    <colspec colname="{position()}" 
      colwidth="{concat(@width, '*')}"/>
  </xsl:template>
  
  <xsl:template match="rsiwp:tr">
    <row>
      <xsl:apply-templates/>
    </row>
  </xsl:template>
  
  <xsl:template match="rsiwp:td">
    <entry>
      <xsl:apply-templates/>
    </entry>
  </xsl:template>
  
  
  <xsl:template match="rsiwp:run" mode="p-content">
    <xsl:variable name="tagName" as="xs:string"
      select="
      if (@tagName) 
      then string(@tagName)
      else 'ph'
      "
    />
    <xsl:if test="not(./@tagName)">
      <xsl:message> + [WARNING] No style to tag mapping for character style "<xsl:sequence select="string(@style)"/>"</xsl:message>
    </xsl:if>
    <xsl:element name="{$tagName}">
      <xsl:apply-templates mode="#current"/>
    </xsl:element>
  </xsl:template>
  
  <xsl:template match="text()" mode="p-content">
    <xsl:copy/>
  </xsl:template>
  
  <xsl:template name="makeTopic">
    <xsl:param name="content" as="element()+"/>
    <xsl:param name="level" as="xs:double"/><!-- Level of this topic -->
    
    <xsl:variable name="firstP" select="$content[1]"/>
    <xsl:variable name="nextLevel" select="$level + 1" as="xs:double"/>
    
    <xsl:variable name="bodyType" as="xs:string"
      select="
      if ($firstP/@bodyType)
      then $firstP/@bodyType
      else 'body'
      "
    />
    
    <xsl:variable name="prologType" as="xs:string"
      select="
      if ($firstP/@prologType and $firstP/@prologType != '')
      then $firstP/@prologType
      else 'prolog'
      "
    />
    
    <xsl:element name="{local:getTopicType($firstP)}">
      <xsl:attribute name="id" select="generate-id($firstP)"/>
      <xsl:variable name="titleTagName" as="xs:string"
        select="if ($firstP/@tagName)
        then $firstP/@tagName
        else 'title'
        "
      />
      <xsl:apply-templates select="$firstP"/>
      <xsl:for-each-group select="$content[position() > 1]" 
        group-starting-with="*[@structureType = 'topicTitle' and @level = string($nextLevel)]">
        <xsl:choose>
          <xsl:when test="current-group()[position() = 1] and current-group()[1][@structureType != 'topicTitle']">
            <!-- Prolog and body elements for the topic -->
            <!-- NOTE: can't process title itself here because we're using title elements to define
                 topic boundaries.
              -->
            <xsl:apply-templates select="current-group()[@topicZone = 'titleAlts']"/>        
            <xsl:apply-templates select="current-group()[@topicZone = 'shortdesc']"/>             
            <xsl:if test="current-group()[@topicZone = 'prolog' or $level = 0]">
              <xsl:choose>
                <xsl:when test="$level = 0">
                  <xsl:element name="{$prologType}">
                    <!-- For root topic, can pull metadata from anywhere in the incoming document. -->
                    <xsl:apply-templates select="root($firstP)//*[@containingTopic = 'root' and 
                                                                  @topicZone = 'prolog' and 
                                                                  contains(@baseClass, ' topic/author ')]"/>                        
                    <xsl:apply-templates select="root($firstP)//*[@containingTopic = 'root' and 
                                                                  @topicZone = 'prolog' and 
                                                                  contains(@baseClass, ' topic/data ')
                                                                  ]"/>                        
                  </xsl:element>                  
                </xsl:when>
                <xsl:when test="current-group()[@topicZone = 'prolog' and @containingTopic != 'root']">
                  <xsl:element name="{$prologType}">
                    <xsl:apply-templates select="//*[@containingTopic = 'root' and @topicZone = 'prolog']"/>
                  </xsl:element>
                </xsl:when>
                <xsl:otherwise/><!-- Must be only root-level prolog elements in this non-root topic context -->
              </xsl:choose>
            </xsl:if>
            <xsl:if test="current-group()[@topicZone = 'body']">
              <xsl:message> + [DEBUG] current group is topicZone body</xsl:message>
              <xsl:element name="{$bodyType}">
                <xsl:call-template name="handleBodyParas">
                  <xsl:with-param name="bodyParas" select="current-group()[@topicZone = 'body']" as="element()*"/>
                </xsl:call-template>
              </xsl:element>                  
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
<!--            <xsl:message> + [DEBUG] makeTopic(): Calling makeTopic...</xsl:message>-->
            <xsl:call-template name="makeTopic">
              <xsl:with-param name="content" select="current-group()"/>
              <xsl:with-param name="level" select="$level + 1"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>        
      </xsl:for-each-group>
    </xsl:element>
  </xsl:template>
  
  <xsl:template name="handleBodyParas">
    <xsl:param name="bodyParas" as="element()*"/>
    
    <xsl:for-each-group select="$bodyParas" group-adjacent="boolean(@containerType)">
      <xsl:choose>
        <xsl:when test="@containerType">
          <xsl:variable name="containerGroup" as="element()">
            <containerGroup>
              <xsl:sequence select="current-group()"/>
            </containerGroup>
          </xsl:variable>
          <xsl:apply-templates select="$containerGroup"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="current-group()"/>
        </xsl:otherwise>
      </xsl:choose>
      
    </xsl:for-each-group>
  </xsl:template>
  
  <xsl:template match="containerGroup">
    <xsl:message> + [DEBUG] Handling groupContainer...</xsl:message>
    
    <xsl:call-template name="processLevelNContainers">
      <xsl:with-param name="context" select="*" as="element()*"/>
      <xsl:with-param name="level" select="1" as="xs:integer"/>
      <xsl:with-param name="currentContainer" select="'body'" as="xs:string"/>
    </xsl:call-template>    
  </xsl:template>
  
  <xsl:template name="processLevelNContainers">
    <xsl:param name="context" as="element()*"/>
    <xsl:param name="level" as="xs:integer"/>
    <xsl:param name="currentContainer" as="xs:string"/>
    <xsl:message> + [DEBUG] processLevelNContainers, level="<xsl:sequence select="$level"/>"</xsl:message>
    <xsl:message> + [DEBUG]   currentContainer="<xsl:sequence select="$currentContainer"/>"</xsl:message>
    <xsl:for-each-group select="$context[@level = $level]" group-adjacent="@containerType">
      <xsl:message> + [DEBUG]   @containerType="<xsl:sequence select="string(@containerType)"/>"</xsl:message>
      <xsl:message> + [DEBUG]   $currentContainer != @containerType="<xsl:sequence select="$currentContainer != string(@containerType)"/>"</xsl:message>
      <xsl:choose>
        <xsl:when test="$currentContainer != string(@containerType)">
          <xsl:message> + [DEBUG ]  currentContainer != @containerType</xsl:message>
          <xsl:element name="{@containerType}">
            <xsl:for-each select="current-group()">
              <xsl:call-template name="handleGroupSequence">
                 <xsl:with-param name="level" select="$level"/>
              </xsl:call-template>
            </xsl:for-each>
          </xsl:element>
        </xsl:when>
        <xsl:otherwise>
          <xsl:for-each select="current-group()">
            <xsl:call-template name="handleGroupSequence">
              <xsl:with-param name="level" select="$level"/>
            </xsl:call-template>
          </xsl:for-each>
        </xsl:otherwise>
      </xsl:choose>
      
    </xsl:for-each-group>    
  </xsl:template>
  
  <xsl:template name="handleGroupSequence">
    <xsl:param name="level"/>
    <xsl:choose>
      <xsl:when test="@containerType = 'dl' and @structureType = 'dt'">
        <xsl:message> + [DEBUG] Found a dl-contained item.</xsl:message>
        <xsl:element name="{@dlEntryType}">
          <xsl:call-template name="transformPara"/>          
          <xsl:variable name="followingSibling" as="element()?" select="following-sibling::*[1]"/>
          <xsl:if test="not($followingSibling/@structureType = 'dd')">
            <xsl:message> +[WARNING] Paragraph following a paragraph mapped to "dt" is not mapped to "dd". Found "<xsl:sequence 
              select="string($followingSibling/@structureType)"/>"</xsl:message>
          </xsl:if>
          <xsl:for-each select="$followingSibling">
            <xsl:call-template name="transformPara"/>
          </xsl:for-each>
          <!-- FIXME: This isn't going to handle nested paras within DD -->
        </xsl:element>
      </xsl:when>
      <xsl:when test="@containerType = 'dl' and @structureType = 'dd'"/><!-- Handled by dt processing -->
      <xsl:when test="following-sibling::*[1][@level &gt; $level]">
        <xsl:variable name="me" select="." as="element()"/>
        <xsl:element name="{@tagName}">
          <xsl:call-template name="transformParaContent"/>
          <xsl:message> + [DEBUG]   Found following lower-level siblings...</xsl:message>
          <xsl:call-template name="processLevelNContainers">
            <xsl:with-param name="context" 
              select="following-sibling::*[(@level = $level + 1) and 
              preceding-sibling::*[@level = $level][1][. is $me]]" as="element()*"/>
            <xsl:with-param name="level" select="$level + 1" as="xs:integer"/>
            <xsl:with-param name="currentContainer" select="@tagName" as="xs:string"/>
          </xsl:call-template>
        </xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="transformPara"/>
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:template>
  
  <xsl:template match="rsiwp:break" mode="p-content">
    <br/>
  </xsl:template>
  
  <xsl:template match="rsiwp:tab" mode="p-content">
    <tab/>
  </xsl:template>
  
  <xsl:template match="rsiwp:hyperlink" mode="p-content">
    <xsl:element name="{@tagName}">
      <!-- Not all Word hyperlinks become DITA hyperlinks: -->
      <xsl:if test="@structureType = 'xref'">
        <xsl:attribute name="href" select="@href"/>
        <xsl:attribute name="scope" select="@scope"/>
      </xsl:if>
      <xsl:apply-templates mode="#current"/>
    </xsl:element>
  </xsl:template>
  
  <xsl:template match="rsiwp:image" mode="p-content">
    <art>
      <art_title><xsl:sequence select="string(@src)"/></art_title>
      <image href="{@src}">
        <alt><xsl:sequence select="string(@src)"/></alt>
      </image>
    </art>
  </xsl:template>
  
  <xsl:function name="local:isRootTopicTitle" as="xs:boolean">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleName" as="xs:string"
      select="$context/@style"
    />
    <xsl:choose>
      <xsl:when test="$styleName = '' or $styleName = '[None]'">
        <xsl:sequence select="false()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()?"
          select="key('styleMaps', $styleName, $styleMapDoc)[1]"
        />
        <xsl:sequence
          select="
          if ($styleMap)
          then $styleMap/@level = '0'
          else false()
          "
        />
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:function>
  
  <xsl:function name="local:isTopicTitle" as="xs:boolean">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleId" as="xs:string"
      select="$context/@style"
    />
    <xsl:choose>
      <xsl:when test="$styleId = '' or $styleId = '[None]'">
        <xsl:sequence select="false()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()"
          select="key('styleMaps', $styleId, $styleMapDoc)[1]"
        />
        <xsl:sequence
          select="
          if ($styleMap)
          then $styleMap/@structureType = 'topicTitle'
          else false()
          "
        />
      </xsl:otherwise>
    </xsl:choose>    
  </xsl:function>
  
  <xsl:function name="local:getTopicType" as="xs:string">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleId" as="xs:string"
      select="$context/@style"
    />
    <xsl:choose>
      <xsl:when test="$styleId = '' or $styleId = '[None]'">
        <xsl:sequence select="'unknown-topic-type'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()"
          select="key('styleMaps', $styleId, $styleMapDoc)[1]"
        />
        <xsl:sequence
          select="
          if ($styleMap and $styleMap/@topicType)
          then string($styleMap/@topicType)
          else 'unknown-topic-type'
          "
        />
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:function>
  
  <xsl:function name="local:debugMessage">
    <xsl:param name="msg" as="xs:string"/>
    <xsl:message> + [DEBUG] <xsl:sequence select="$msg"/></xsl:message>
  </xsl:function>
  
  <xsl:function name="local:reportPara">
    <xsl:param name="para" as="element()?"/>
    <xsl:if test="$para">
      <xsl:sequence 
        select="concat('[', 
                       name($para),
                       ' ',
                       ' tagName=',
                       $para/@tagName,
                       if ($para/@level)
                          then concat(' level=', $para/@level)
                          else '',
                       if ($para/@containerType)
                          then concat(' containerType=', $para/@containerType)
                          else '',
                       ']',
                       substring(normalize-space($para), 1,20)
                       )"
      />
    </xsl:if>
  </xsl:function>
  
  <xsl:template match="rsiwp:*" priority="-0.5" mode="p-content">
    <xsl:message> + [WARNING] docx2dita[p-content]: Unhandled element <xsl:sequence select="name(..)"/>/<xsl:sequence select="name(.)"/></xsl:message>
  </xsl:template>
  
  <xsl:template match="rsiwp:*" priority="-0.5">
    <xsl:message> + [WARNING] docx2dita: Unhandled element <xsl:sequence select="name(..)"/>/<xsl:sequence select="name(.)"/></xsl:message>
  </xsl:template>

</xsl:stylesheet>
